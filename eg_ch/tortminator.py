# Дан прямоугольный торт, который имеет вид таблицы размером r×c.
# Каждая ячейка таблицы содержит либо гадкую клубничку, либо является пустой.
# Тортминатор намерен съесть этот торт! Каждый раз, когда он ест, он выбирает
# строку или столбец, не содержащие гадкой клубнички, а содержащие по крайней
# мере одну несъеденную ячейку торта. Затем Тортминатор поедает все выбранные
# им ячейки торта. Тортминатор может есть сколько угодно раз.
#
# Пожалуйста, выведите максимальное количество ячеек, которые может съесть Тортминатор.
# # Входные данные
# # Первая строка содержит два целых числа r и c (2≤r,c≤10), обозначающих
# количество строк и количество столбцов в торте. Следующие r строк содержат
# по c символов — j-ый символ i-ой строки обозначает содержимое ячейки
# в строке i и столбце j, и имеет одно из следующих значений:
#
# символ '.' обозначает ячейку торта без гадкой клубнички;
# символ 'S' обозначает ячейку торта с гадкой клубничкой.
# Выходные данные#
# Выведите максимальное количество ячеек торта, которые может съесть тортминатор.

# var_1

r, c = map(int, input().split())
tort = []
for i in range(r):
    tort.append(input())
mas = [[False] * c for i in range(r)]
for i in range(r):
    if 'S' not in tort[i]:
        for j in range(c):
            mas[i][j] = True
for j in range(c):
    is_find = False
    for i in range(r):
        if tort[i][j] == 'S':
            is_find = True
            break
    if not is_find:
        for i in range(r):
            mas[i][j] = True
count = 0
for row in mas:
    count += row.count(True)
print(count)

# var_2

n, m = map(int, input().split())
c_n = [1] * m
c_m = 0
for _ in range(n):
    s = input()
    if 'S' in s:
        for i in range(m):
            if s[i] == 'S':
                c_n[i] = 0
    else:
        c_m += 1
print(c_m * m + c_n.count(1) * (n - c_m))

# var_3

# put your python code here
n, m = map(int, input().split())
s = []  # массива для ввода данных
s_stolb = []  # массив, в котором я поменяю местами строки и столбцы
count_strok = 0  # буду считать количество строк, где нет клубники
count_stolb = 0  # и количество столбцов, где нет клубники

for i in range(n):
    s.append(input())  # ввод исходных данных

for i in range(n):
    if 'S' not in s[i]:
        count_strok += 1  # проверяю каждую строку на наличие клубники, если в строке клубники нет - считаю

# в этом вложенном цикле прохожу по столбцам
for j in range(m):
    s1 = []  # при каждом прохоже нового столбца обнуляю этот массив
    for i in range(n):  # во внутреннем цикле прохожу по значениям строк для каждого столбца
        s1.append(s[i][j])  # в массив s1 добавляю значения строк из каждого столбца
    s_stolb.append(s1)  # в этот массив в качестве элемента добавляю полученное на втруннем цикле значение
    # мы прошлись по столбцам вниз - а значит в этом массиве сделали столбцы строками
# на этом цикле проверяю есть ли клубника в бывших столбцах (ныне строках)
for i in range(m):
    if 'S' not in s_stolb[i]:
        count_stolb += 1

print(count_strok * m + count_stolb * (n - count_strok))
# и считаю. Количество строк, где не было клубники, умножаю на количество элементов в этих строках(m).
# Изначальное количество строк(n) равно количеству элементов в каждом столбце. Вычитаю n те элементы,
# которые уже подсчитаны в строках
# и складываю съеденные элементы из строк и съеденные из столцов. profit!

